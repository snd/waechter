// Generated by CoffeeScript 1.9.3
var slice = [].slice;

(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define(['is_js', 'bluebird'], factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory(require('is_js'), require('bluebird'));
  } else {
    return root.waechter = factory(root.is, root.Promise);
  }
})(this, function(isjs, Promise) {
  var waechter;
  waechter = {
    errors: {}
  };
  waechter.predicateToValidator = function(predicate, error) {
    return function(value) {
      if (predicate(value)) {
        return null;
      } else {
        if ('function' === typeof error) {
          return error(value);
        } else {
          return error;
        }
      }
    };
  };
  waechter.schemaToValidator = function(schema) {
    return function(data) {
      var errors;
      if ('object' !== typeof data) {
        return 'must be an object';
      }
      errors = {};
      Object.keys(schema).forEach(function(key) {
        var error, validator;
        validator = schema[key];
        if ('function' !== typeof validator) {
          throw new Error("validator must be a function but is " + (typeof validator));
        }
        error = validator(data[key]);
        if (error != null) {
          return errors[key] = error;
        }
      });
      if (Object.keys(errors).length === 0) {
        return null;
      } else {
        return errors;
      }
    };
  };
  waechter.chainValidators = function() {
    var validators;
    validators = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(value) {
      var errors, i, len, validator;
      for (i = 0, len = validators.length; i < len; i++) {
        validator = validators[i];
        errors = validator(value);
        if (errors != null) {
          return errors;
        }
      }
      return null;
    };
  };
  waechter.isThenable = function(x) {
    return (x === Object(x)) && ('function' === typeof x.then);
  };
  waechter.schemasToLazyAsyncValidator = function() {
    var schemas;
    schemas = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(data) {
      var errors, iterator;
      if ('object' !== typeof data) {
        return Promise.resolve('must be an object');
      }
      errors = {};
      iterator = function(schema) {
        var pending;
        pending = {};
        Object.keys(schema).forEach(function(key) {
          var error, validator;
          if (errors[key] != null) {
            return;
          }
          validator = schema[key];
          if ('function' !== typeof validator) {
            throw new Error("validator must be a function but is " + (typeof validator));
          }
          error = validator(data[key]);
          if (waechter.isThenable(error)) {
            return pending[key] = error;
          } else if (error != null) {
            return errors[key] = error;
          }
        });
        return Promise.props(pending).then(function(resolved) {
          return Object.keys(resolved).forEach(function(key) {
            if (resolved[key] != null) {
              return errors[key] = resolved[key];
            }
          });
        });
      };
      return Promise.all(schemas).each(iterator).then(function() {
        if (Object.keys(errors).length === 0) {
          return null;
        } else {
          return errors;
        }
      });
    };
  };
  waechter.optional = function(validator) {
    return function(value) {
      if (isjs.undefined(value)) {
        return;
      }
      return validator(value);
    };
  };
  waechter.exist = waechter.predicateToValidator(isjs.existy, function() {
    return waechter.errors.exist;
  });
  waechter.errors.exist = 'must not be null or undefined';
  waechter.string = waechter.chainValidators(waechter.exist, waechter.predicateToValidator(isjs.string, function() {
    return waechter.errors.string;
  }));
  waechter.errors.string = 'must be a string';
  waechter.stringNotEmpty = waechter.chainValidators(waechter.string, waechter.predicateToValidator(isjs.not.empty, function() {
    return waechter.errors.stringNotEmpty;
  }));
  waechter.errors.stringNotEmpty = 'must not be empty';
  waechter.email = waechter.chainValidators(waechter.string, waechter.predicateToValidator(isjs.email, function() {
    return waechter.errors.email;
  }));
  waechter.errors.email = 'must be an email address';
  waechter.stringMinLength = function(min) {
    var predicate;
    predicate = function(value) {
      return value.length >= min;
    };
    return waechter.chainValidators(waechter.stringNotEmpty, waechter.predicateToValidator(predicate, function() {
      return waechter.errors.stringMinLength(min);
    }));
  };
  waechter.errors.stringMinLength = function(min) {
    return "must be at least " + min + " characters long";
  };
  return waechter;
});
